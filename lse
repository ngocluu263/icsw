#!/usr/bin/python-init -Ot
# -*- mode: python -*-
# -*- coding: utf-8 -*-
#
# Copyright (C) 2001,2002,2003,2004,2005,2006,2007,2008,2009,2010 Andreas Lang-Nevyjel
#
# Send feedback to: <lang-nevyjel@init.at>
# 
# This file is part of cluster-backbone
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

import sys
import getopt
import os
import os.path
import logging_tools
import getopt
import time
import datetime
import commands
import process_tools

class error_rec(object):
    def __init__(self, pid, s_name, uid, uname, gid, gname):
        self.__pid = pid
        self.__source_name = s_name
        self.__uid, self.__gid = (uid, gid)
        self.__uname, self.__gname = (uname, gname)
        self.__lines = []
        self.set_idx()
    def set_idx(self, idx=0):
        self.__idx = idx
    def get_pid(self):
        return self.__pid
    def get_uid(self):
        return self.__uid
    def get_uname(self):
        return self.__uname
    def get_source_name(self):
        return self.__source_name
    def add_line(self, l_date, state, line):
        if not self.__lines:
            self.__err_time = datetime.datetime(*time.strptime(l_date)[0:6])
            self.__err_date = datetime.datetime(*time.strptime(l_date)[0:3])
        self.__lines.append((state, line))
    def set_header_parts(self, fl):
        fl.set_header_string(0, ["Idx", "Time", "Pid", "Lines", "user", "group", "source"])
        fl.set_format_string("Idx"  , "d", "")
        fl.set_format_string("Pid"  , "d", "")
        fl.set_format_string("Lines", "d", "")
        fl.set_format_string("user" , "s", "")
        fl.set_format_string("group", "s", "")
    def get_err_time_str(self):
        diff_time = self.__err_date.now() - self.__err_date
        if diff_time.days == 0:
            t_str = self.__err_time.strftime("today, %H:%M:%S")
        elif diff_time.days == 1:
            t_str = self.__err_time.strftime("yesterday, %H:%M:%S")
        else:
            t_str = self.__err_time.strftime("%a, %d. %b %Y %H:%M:%S")
        return t_str
    def get_form_parts(self):
        return [self.__idx,
                self.get_err_time_str(),
                self.__pid,
                len(self.__lines),
                "%d (%s)" % (self.__uid, self.__uname),
                "%d (%s)" % (self.__gid, self.__gname),
                self.__source_name]
    def get_header(self):
        return "Error %d occured %s, pid %d, uid/gid is (%d/%d [%s/%s]), source %s, %s:" % (self.__idx,
                                                                                            self.get_err_time_str(),
                                                                                            self.__pid,
                                                                                            self.__uid,
                                                                                            self.__gid,
                                                                                            self.__uname,
                                                                                            self.__gname,
                                                                                            self.__source_name,
                                                                                            logging_tools.get_plural("line", len(self.__lines)))
    def show_lines(self):
        f_str = "%%3d (%%%ds) : %%s" % (max([len(x) for x, y in self.__lines]))
        return "\n".join([f_str % (l_idx, state, line) for (state, line), l_idx in zip(self.__lines, xrange(len(self.__lines)))])
    def __repr__(self):
        return "error from pid %d (%s)" % (self.__pid,
                                           logging_tools.get_plural("line", len(self.__lines)))
        
def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hs:l:", ["help", "stat", "noempty", "clear"])
    except:
        exc_info = sys.exc_info()
        print "Error parsing commandline %s: %s" % (" ".join(sys.argv[1:]),
                                                    process_tools.get_except_info())
        sys.exit(1)
    pname = os.path.basename(sys.argv[0])
    err_file_name = "/var/log/cluster/logging-server/err_py"
    opt_dict = {"overview"  : True,
                "show_idxs" : [],
                "last_idxs" : 0,
                "show_stat" : False,
                "noempty"   : False,
                "clear_it"  : False}
    for opt, arg in opts:
        if opt in ["-h", "--help"]:
            print "Usage: %s [OPTIONS]" % (pname)
            print " where options is one or more of"
            print "  -h, --help          this help"
            print "  -s IDX              show index IDX"
            print "  -l NUM              show last NUM errors"
            print "  --stat              show statistics (error per uid)"
            print "  --noempty           suppress empty error_lines"
            print "  --clear             tars actual error file"
            sys.exit(1)
        elif opt == "--stat":
            opt_dict["show_stat"] = True
            opt_dict["overview"] = False
        elif opt == "-s":
            if arg.isdigit():
                opt_dict["show_idxs"] = [int(arg)]
                opt_dict["overview"] = False
            else:
                print "Cannot parse idx '%s'" % (arg)
                sys.exit(2)
        elif opt == "-l":
            if arg.isdigit():
                opt_dict["last_idxs"] = int(arg)
                opt_dict["overview"] = False
            else:
                print "Cannot parse idx '%s'" % (arg)
                sys.exit(2)
        elif opt == "--noempty":
            opt_dict["noempty"] = True
        elif opt == "--clear":
            opt_dict["clear_it"] = True
    if not os.path.isfile(err_file_name):
        print "%s does not exist" % (err_file_name)
        sys.exit(1)
    if opt_dict["clear_it"]:
        new_file_name = "%s_%s.tar.bz2" % (err_file_name,
                                           time.strftime("%Y-%m-%d_%H:%M:%S", time.localtime()))
        print "taring %s to %s ..." % (err_file_name, new_file_name)
        stat, out = commands.getstatusoutput("tar cpsjf %s %s" % (new_file_name, err_file_name))
        if stat:
            print "*** error (%d): %s" % (stat, out)
        else:
            os.unlink(err_file_name)
        sys.exit(stat)
    try:
        err_lines = [x.strip() for x in file(err_file_name, "r").read().split("\n") if x.count("from pid")]
    except IOError:
        print "Cannot read '%s': %s" % (err_file_name,
                                        process_tools.get_except_info())
        sys.exit(1)
    print "Found error_file %s with %d lines" % (err_file_name, len(err_lines))
    errs_found, act_err = ([], None)
    act_idx, idx_dict = (0, {})
    for line in err_lines:
        line_parts = line.split(":")
        # date is always the first 4 parts
        line_date = ":".join(line_parts[0:3]).strip()
        info_part = line_parts[3].strip()
        err_line = ":".join(line_parts[4:])
        # parse info_part
        try:
            if info_part.startswith("("):
                line_state = ""
            else:
                line_state = info_part.split()[0]
                info_part = info_part[len(line_state):].strip()
            info_parts = info_part.split()
            # skip error-thread name and "from pid" string
            info_parts.pop(0)
            info_parts.pop(0)
            info_parts.pop(0)
        except:
            print "Error pre-parsing line '%s'" % (line)
        else:
            try:
                # get pid
                line_pid = int(info_parts.pop(0))
                # unknown or full source
                if len(info_parts) == 7:
                    # full source
                    line_s_name = info_parts[0][1:]
                    line_uid = int(info_parts[2])
                    line_uname = info_parts[3][1:-2]
                    line_gid = int(info_parts[5])
                    line_gname = info_parts[6][1:-3]
                else:
                    line_s_name = info_parts[0][1:-1]
                    line_uid, line_gid = (-1, -1)
                    line_uname, line_gname = ("unknown", "unknown")
                if not act_err or act_err.get_pid() != line_pid:
                    act_idx += 1
                    act_err = error_rec(line_pid,
                                        line_s_name,
                                        line_uid,
                                        line_uname,
                                        line_gid,
                                        line_gname)
                    act_err.set_idx(act_idx)
                    idx_dict[act_idx] = act_err
                    errs_found.append(act_err)
                if err_line.strip() or not opt_dict["noempty"]:
                    act_err.add_line(line_date, line_state, err_line)
            except:
                print "Error parsing line '%s'" % (line)
    print "Found %s" % (logging_tools.get_plural("error record", len(errs_found)))
    if opt_dict["overview"]:
        if errs_found:
            out_list = logging_tools.form_list()
            errs_found[0].set_header_parts(out_list)
            for err in errs_found:
                out_list.add_line(err.get_form_parts())
            print str(out_list)
    elif opt_dict["show_stat"]:
        uid_dict = {}
        for err in errs_found:
            uid_dict.setdefault(err.get_uid(), []).append(err)
        all_uids = uid_dict.keys()
        all_uids.sort()
        out_list = logging_tools.form_list()
        out_list.set_header_string(0, ["uid", "uname", "# err", "# sources", "sources"])
        out_list.set_format_string("uid", "d", "")
        out_list.set_format_string("# err", "d", "")
        out_list.set_format_string("# sources", "d", "")
        for uid in all_uids:
            uid_stuff = uid_dict[uid]
            diff_sources = []
            for err in uid_stuff:
                if err.get_source_name() not in diff_sources:
                    diff_sources.append(err.get_source_name())
            diff_sources.sort()
            out_list.add_line((uid,
                               uid_stuff[0].get_uname(),
                               len(uid_stuff),
                               len(diff_sources),
                               ", ".join(diff_sources)))
        print str(out_list)
    elif opt_dict["last_idxs"]:
        idx_l = idx_dict.keys()
        idx_l.sort()
        idx_show = []
        while opt_dict["last_idxs"] and idx_l:
            opt_dict["last_idxs"] -= 1
            idx_show.append(idx_l.pop(-1))
        idx_show.reverse()
        opt_dict["show_idxs"] = idx_show
    if opt_dict["show_idxs"]:
        for idx in opt_dict["show_idxs"]:
            if idx_dict.has_key(idx):
                act_err = idx_dict[idx]
                print act_err.get_header()
                print act_err.show_lines()
            else:
                print "Index %d not in index_list %s" % (idx,
                                                         logging_tools.compress_num_list(idx_dict.keys()))

if __name__ == "__main__":
    main()
