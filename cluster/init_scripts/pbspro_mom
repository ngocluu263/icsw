#!/bin/sh 
#
#    PBS init script
#
#	Reconized arguments:
#	    start   - start PBS
#	    stop    - terminate PBS
#	    restart - terminate and start PBS
#	    status  - report PBS deamon pids
#
#
# chkconfig: 2345 90 10
# description: The Portable Batch System (PBS) is a flexible workload 
# management  system. It operates on # networked, multi-platform UNIX 
# environments, including heterogeneous clusters of workstations, 
# supercomputers, and massively parallel systems. 
#
### BEGIN INIT INFO
# Provides:      pbspro
# Required-Start: $network $syslog autofs
# Required-Stop:
# Default-Start: 3 5
# Default-Stop: 0 1 2 6
# Description:   start pbspro mom
### END INIT INFO


[ -f /etc/batch_system ] && cat /etc/batch_system | grep PBSPRO >/dev/null || exit -1

conf=${PBS_CONF_FILE:-/etc/pbs.conf}

if [ -f "${conf}" ] ; then
  source ${conf}
  if [ -z "${PBS_START_SERVER}" ] ; then
      PBS_START_SERVER=0
  fi
  UNIX95=1
  export UNIX95
else
  echo "***"
  echo "*** Cannot find PBS configuration file: ${conf}"
  echo "***"
  exit 1
fi

. /etc/rc.status

update_pids() {
  if [ -f ${PBS_HOME}/mom_priv/mom.lock ] ; then
    pbs_mom_pid=`cat ${PBS_HOME}/mom_priv/mom.lock`
  else
    pbs_mom_pid=-1
  fi
}

# check_started - check if a particular pid is the program which is expected.
#                 pbs stores the pid of the currently running incarnation of 
#                 itself.  This function is used to see if that pid is correct 
#		  program.
# 	$1 - the pid
# 	$2 - the program name (pbs_server pbs_mom pbs_sched)
#
# return value: 0 - program is already running
#		1 - program is not running
#
: check_started
check_started() {

  ps_out=`ps -p $1 -o args 2> /dev/null | tail -1`
  if [ -z "${ps_out}" -o "`echo ${ps_out} | cut -c1`" = "[" ]  ; then
    ps_out=`ps -p $1 -o command 2> /dev/null | tail -1`
    if [ -z "${ps_out}" ]; then
	return 1
    fi
  fi

# strip out everything except executable name
  prog_name=`echo ${ps_out} | awk '{print $1}' | \
	awk -F/ '{print $NF}' | awk '{print $1}'`

  if [ "${prog_name}" = $2 ] ; then
    return 0;
  fi

  return 1;
}

# check_prog - this function checks to see if a prog is still running.  It will
#              get the pid out of the prog.lock file and run check_started 
#	       on that pid.
#
#	$1 is either "server" "mom" or "sched"
#
# return value: 0 - program is still running
#		1 - program is not running
#
: check_prog
check_prog() {
  pid_file=${PBS_HOME}/${1}_priv/${1}.lock

  if [ -f ${pid_file} ] ; then
    pid=`cat ${pid_file}`
    if [ -n "${pid}" ] ; then
      if check_started "${pid}" "pbs_${1}" ; then
	return 0
      else
	return 1
      fi
    else
      return 1
    fi
  fi
  # Since the pid file does not exist, PBS has never been run
  return 1
}

start_pbs() {
    echo "Starting PBS"

    if [ "${PBS_START_MOM}" -gt 0 ] ; then
      if check_prog "mom" ; then
	echo "PBS mom already running."
      else
	${PBS_EXEC}/sbin/pbs_mom -r
	echo "PBS mom"
      fi
    fi
}

stop_pbs() {
    update_pids 
    echo "Stopping PBS"
    if [ "${PBS_START_MOM}" -gt 0 ] ; then
      if check_prog "mom" ; then
	kill ${pbs_mom_pid}
	echo "PBS mom - was pid: ${pbs_mom_pid}"
      fi
    fi
}

status_pbs() {
    update_pids
    if [ "${PBS_START_MOM}" -gt 0 ] ; then
      if check_prog "mom" ; then
	echo "pbs_mom is pid ${pbs_mom_pid}"
      else
	echo "pbs_mom is not running"
      fi
    fi
}

: main code
# lets see how we were called
case "`basename $0`" in
  pbs_start) start_pbs ; exit 0 ;;
  pbs_stop) stop_pbs ; exit 0 ;;
esac

case "$1" in
  status) status_pbs ;;
  start) start_pbs ;;
  stop) stop_pbs ;;
  restart) echo "Restarting PBS" ; stop_pbs ; start_pbs ;;
  *) echo "Usage: `basename $0` {start|stop|restart|status}" ; exit 1 ;;
esac

